# 概述

这一章开始于对Vulkan以及它所解决的问题的介绍。然后我们将会看看为了画出第一个三角形所需要的步骤。这可以让你纵观全局并且理清后续每一章在整个过程中的位置。我们将会以展示Vulkan API的结构以及它们的一般使用模式作结。

## Vulkan的起源

和之前的那些图形API一样，Vulkan也被设计成了跨GPU平台抽象的。之前的那些图形API的问题在于，那个时代的API都被设计成了与显卡紧密相关的，并且被限制在了固定管线上。程序员们只能用什么“标准格式的顶点数据”，并且在显卡厂商的怜悯之下进行光照和着色操作。

随着显卡架构的不断发展，他们开始提供越来越多的可编程功能。这些新功能都是以某种方式利用已有的API被集成进去的。这就造成了不理想的抽象，以及在显卡将程序员的意图映射到现代图形架构时产生的许多猜测。这就是驱动要经常更新来为游戏提供更好的显示性能的原因，当然有的时候也是为了自己的利益。出于这种复杂性，应用开发者们也得处理各种供应商的显卡之间的不一致性，比如[着色器](https://zh.wikipedia.org/wiki/%E7%9D%80%E8%89%B2%E5%99%A8)的格式。除了这些新功能之外，在过去的十年中也能看到许多拥有强劲显卡的移动设备。这些移动设备的GPU根据功耗和空间需求的不同有着不同的架构。一个有代表性的例子就是[基于图块渲染](https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%9D%97%E6%B8%B2%E6%9F%93)，通过给予程序员更大的控制权来获得更好的性能。之前的图形API的另一个问题在于不支持多线程，这往往是造成CPU端性能瓶颈的原因。

Vulkan通过根据现代图形架构从头重新设计的方式解决了这个问题。它通过让程序员使用更多的API来明确地声明自己意图的方式降低了驱动的开销，并且支持多线程，使得命令可以被并行地创建和提交。它通过将着色器程序通过单独的编译器编译成字节码的方式减少了编译着色器时的不一致性。最后，它承认现代显卡的计算能力，并且将计算和图形功能合并到了同一个API中。

## 画一个三角形需要做什么

我们现在来大致看看在一个行为良好的Vulkan程序中渲染一个三角形所需要的所有步骤。此处介绍的所有概念在接下来的章节中会被详细介绍。此处只是为了让你对每个具体组件之间的关系有一个整体上的了解。

### 第一步 实例和选择物理设备

一个Vulkan应用程序以通过一个[`VkInstance`](https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkInstance.html)设置Vulkan API开始。创建一个实例则需要你描述你的应用程序并且设置你想使用的API扩展。创建实例之后，你可以查询支持Vulkan的硬件设备并且选择一个或多个[`VkPhysicalDevice`](https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPhysicalDevice.html)来使用。你可以查询设备的属性（比如显存大小）和能力来选择一个你想要的设备，比如你想使用独立显卡。